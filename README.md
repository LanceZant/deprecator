

# The Deprecator Project

# Introduction

As software systems evolve, some of the new code represents new ways of doing old things.  Whether this evolution is driven by new requirements that overlap old functionality, the emergence of new tools/libraries and approaches, or merely reflects successive developers doing things their own way, the result is often a confusing mishmash of alternative approaches.  Solving and preventing this problem is the goal of the Deprecator project.

Before diving into the proposed solution, let's take a moment to explore the extent of the problem.  What forces contribute to causing the problem?  What obstacles confront those who would avoid or solve it?

# The Problem

The trouble begins with an existing code base and a new requirement.  This new requirement naturally breaks down into several programming tasks, some of which are likely to be similar to functionality already present in the code.  First opportunity to screw up: the developer may not realize there's a "go by" available in the code, so he invents a second solution without realizing it.  But even if the developer looks for an existing approach, the code may already contains several candidate patterns.  The developer may or may not choose the preferred one to emulate.  After all, unless he is already sensitized to this problem, he is likely to assume that the first candidate he recognizes is the only/preferred one.  How is he to know otherwise?  Even if he discovers that there are conflicting approaches in the code, how is he to know which is preferred?  He may guess wrong, he may not like any of them and invent his own anyway, he may even (hopefully) ask his teammates; they may or may not know, so the code continues to fall into chaos.

But wait, isn't this exactly the problem the deprecation mechanism in Java and other modern languages was supposed to solve?  Why not just deprecate any "old" way of doing something at the moment we begin using an improved alternative?  Let's see how that works out.  At the moment we deprecate code that is currently in use, our builds begin reporting a violation for every usage of the deprecated function.  Isn't that what we want?  We just go and fix those violations, right?  If it were a little used function in a small (toy) application, we would, but what about several hundred uses spread out over a few hundred classes, most of which we have no other need to change and no time to retest?  And what about the tens of other deprecated functions, with their own hundreds of uses in a mission critical enterprise application?  We simply are not going to fix all those violations at once, now or ever.  But until we do, any new warnings our other changes might introduce will be lost in a fog of deprecation warnings.

So we're caught in a dilemma.  Unless we deprecate obsolete functions, there is no practical way for developers to recognize them as such and avoid emulating their use.  But if we do deprecate them, we get so many warnings of issues we already know about that they obscure newly introduced problems, defeating the very purpose of the warnings in the first place.

So we're left with no good options.  All our choices are so fraught with opportunities for error that one would be foolish to rely on any of them.  For the simple and quite defensible reason that we have no reasonable alternative, we give up; we can't solve the problem, so we leave it unsolved in the way that's the least work.  By not deprecating old code, at least we keep the build logs clean enough to see new warnings of other types.  We rely on ad hoc admonitions to the team in the particular cases that cause enough pain to come to our attention, and live with the results.  We know that a process dependent on human diligence is prone to failure; we just don't have anything better in this case.  Until now - enter The Deprecator.

# The Solution

Let's review.  We want a practical way to identify code we want to avoid using and eventually clean up.  In particular, we want something that achieves these goals:

1. Lets us deprecate obsolete code without creating a fog of warnings that obscures newly introduced problems of this or any other type,
2. Marks deprecation violations in the code, not only to warn us off emulating the violations, but to guide us to the preferred alternative,
3. Helps us recognize deprecation violations whose "grandfathered" (suppressed) status should be revoked and encourages us to clean them up when the time comes,
4. But allows us to postpone such clean up, should the encouragement arise during a genuine emergency.  To do so must be quick and easy, but it must also be "loud."

That last point is worth some explanation.  The idea is the same as the fire hose behind a locked glass door.  Anyone can instantly break the glass and deploy the hose.  There's no need for prior management approval.  But there's also no way to do it quietly.  Everyone will know, so there had better be a fire, because afterward, some very assertive people are going to want to hear all about how the fire started, how it got so bad that you needed the hose, and how much better your fire safety plan will be going forward.  In programming, sometimes there really isn't time to clean up the code you're changing for other reasons.  But genuine emergencies are rare, and when they occur they're worth investigating so we can learn from them.

So how do we accomplish all this?  That's the topic of the next section.

## Deprecator Defined

The Deprecator approach to all this comprises a number of components.  Some components are software and others are procedures or working agreements.  To a first approximation, they are as follow:

1. **When obsolete code is recognized as such, deprecate it, and include a comment identifying the preferred alternative.**  This will warn developers away from adding new usages of the obsolete code, or worse, emulating it in a new variation.  The included comment is important.  We want to go beyond obstructing the wrong thing to helping do the right thing.  Even better is to also include commentary about why this approach is deprecated and what advantages the preferred alternative offers, enabling developers to follow the spirit as well as the letter of the guidance on offer.  This achieves goal 1.
2. **As part of deprecating obsolete code, we will run the entire code base through a program that inserts**** @SuppressWarnings("deprecated") ****annotations at the point of every existing violation.**  Suppressing existing violations will keep the build logs "clean" until the appropriate time to clean them up, achieving goal 2.  This program is yet to be designed.  It might begin as a stand-alone script and evolve into an IDE refactoring plug-in.  In any event, it should accept both the deprecated function and the preferred alternative and rationale comments as arguments.  It seems likely that the script would benefit from running in tandem behind the compiler to leverage the compiler's warnings to locate uses of deprecated code.
3. **The version control system will require a special procedure to accept the results of this augmented deprecation script (deprecations of existing code and suppressions of existing violations) into any controlled branch.**  The idea here is to routinely accept the fact that an existing function is now deprecated and that we intend to "grandfather" existing violations, while retaining the ability to discourage additional technical debt and encourage repayment.  A "controlled branch" is any branch destined for production or release.  You may commit anything to an experimental or feature branch; but deprecation suppressions will be blocked from trunk, release, and patch branches, so you'll need to either remove or waive them at merge time.  The need will be clear in the next point; the special procedure is in the one after that.
4. **Any unsuppressed deprecation violation will break a controlled branch build.**  Since we will automatically suppress existing violations of newly deprecated code, a new violation indicates new usage of a deprecated function, and a new suppression indicates an attempt to hide that fact.  Both are forbidden.  Although a simple regex scan can detect suppressions, distinguishing _new_ suppressions and detecting unsuppressed deprecation violations basically require compiling the code.  (This is because the deprecated code is usually elsewhere.  The compiler needs to chase down all references anyway.
5. **A pre-commit hook in the version control system will reject any file containing deprecation warnings, suppressed or otherwise.**  As long as code leaves us alone, we can leave it alone.  The fact that we're changing a file now is the best indicator that we'll be changing it again, so this code is no longer leaving us alone, making it time to clean it up.  Most obviously, we don't want new usage of deprecated code, so unsuppressed warnings are rejected.  But developers are often under time pressure, and it's easy to rationalize that one more violation won't hurt.  Nonsense; when you're in a hole, quit digging.  So we won't let developers simply suppress the warnings.  Furthermore, the "grandfathered" violations that have been suppressed up to now are no longer benign.  This code is under active development, so it's time to clean it up.
6. **There will be a quick easy, and LOUD mechanism to bypass the pre-commit hook.**  This mechanism is yet to be designed, but could take the form of a special pragma or comment in the committed file, or a special parameter passed into the commit process.  However it is implemented, it will also call immediate attention to the bypass and record the culprit and affected files.  E.g. it could turn the build light an odd color and email the particulars to all authorized committers.  The idea is two-fold.  First we want the loud "alarm" to make bypassing the pre-commit hook tantamount to declaring an emergency, deterring such action unless there really is a bona fide emergency.  Second, we want the very act of taking emergency action to launch an incident retrospective to examine root causes and plan repayment of the resulting technical debt.

## Implementation Plans

### Source Languages (Starter Set: Java, JavaScript, Ruby, Groovy, Clojure)

- Java comes first.  It's the oldest of the languages of interest and therefore has the largest legacy code base, which means the biggest near term benefit.  It also has an established deprecation mechanism.  Besides, it's the language I know best.
- Next comes JavaScript.  This is the language with the second largest installed base, and therefore the next biggest payoff.  It also introduces the wrinkles that attend trying to do deprecation in an entirely dynamic language.  (Deprecation and the checking thereof become function calls rather than compiler-oriented annotations.)
- Those two probably take us beyond any reasonable planning horizon, but Ruby, Groovy, and Clojure all look promising.
  - Ruby is the language of the popular Rails and RSpec frameworks.
  - Groovy is gaining popularity with Grails and Spock.
  - Clojure is emerging as a natural way to bring functional programming to enterprise applications and (with ClojurScript) to the browser.

